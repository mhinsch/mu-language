# Autogenerated from a Treetop grammar. Edits may be lost.




module Eta
  include Treetop::Runtime

  def root
    @root ||= :program
  end

  module Program0
    def preamble
      elements[0]
    end

    def code
      elements[1]
    end

    def empty
      elements[2]
    end
  end

  module Program1
    def tree; code.tree; end
  end

  def _nt_program
    start_index = index
    if node_cache[:program].has_key?(index)
      cached = node_cache[:program][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_preamble
    s0 << r1
    if r1
      r2 = _nt_code_block
      s0 << r2
      if r2
        r3 = _nt_empty
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Program0)
      r0.extend(Program1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:program][start_index] = r0

    r0
  end

  def _nt_preamble
    start_index = index
    if node_cache[:preamble].has_key?(index)
      cached = node_cache[:preamble][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_empty_line
      if r2
        r1 = r2
      else
        r3 = _nt_pre_text_line
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

    node_cache[:preamble][start_index] = r0

    r0
  end

  module PreTextLine0
  end

  module PreTextLine1
    def _
      elements[0]
    end

    def EOL
      elements[3]
    end
  end

  def _nt_pre_text_line
    start_index = index
    if node_cache[:pre_text_line].has_key?(index)
      cached = node_cache[:pre_text_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt__
    s0 << r1
    if r1
      if has_terminal?('\G[^{\\n\\r]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          i5 = index
          r6 = _nt_EOL
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s4 << r5
          if r5
            if index < input_length
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("any character")
              r7 = nil
            end
            s4 << r7
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(PreTextLine0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
        if r3
          r8 = _nt_EOL
          s0 << r8
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(PreTextLine1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pre_text_line][start_index] = r0

    r0
  end

  module CodeBlock0
    def exprs
      elements[1]
    end

  end

  module CodeBlock1
    def tree; exprs.tree; end
  end

  def _nt_code_block
    start_index = index
    if node_cache[:code_block].has_key?(index)
      cached = node_cache[:code_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('{', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('{')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_expressions
      s0 << r2
      if r2
        if has_terminal?('}', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('}')
          r3 = nil
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CodeBlock0)
      r0.extend(CodeBlock1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:code_block][start_index] = r0

    r0
  end

  module Expressions0
    def EOL
      elements[0]
    end

    def ex2
      elements[1]
    end
  end

  module Expressions1
    def ex1
      elements[0]
    end

    def ee
      elements[1]
    end
  end

  module Expressions2
    def tree
   			ee.elements.inject(N_Block.new(ex1.tree, interval, "{}")){|res,e|
   				res.add(e.ex2.tree)}
   			end
  end

  def _nt_expressions
    start_index = index
    if node_cache[:expressions].has_key?(index)
      cached = node_cache[:expressions][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_expression
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_EOL
        s3 << r4
        if r4
          r5 = _nt_expression
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Expressions0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Expressions1)
      r0.extend(Expressions2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:expressions][start_index] = r0

    r0
  end

  module Expression0
    def _1
      elements[0]
    end

    def a
      elements[1]
    end

    def _2
      elements[2]
    end
  end

  module Expression1
    def tree; a.tree; end
  end

  def _nt_expression
    start_index = index
    if node_cache[:expression].has_key?(index)
      cached = node_cache[:expression][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt__
    s1 << r2
    if r2
      r3 = _nt_assign
      s1 << r3
      if r3
        r4 = _nt__
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Expression0)
      r1.extend(Expression1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt__
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:expression][start_index] = r0

    r0
  end

  module Assign0
    def t1
      elements[0]
    end

    def _
      elements[1]
    end

    def I_
      elements[3]
    end

    def t2
      elements[4]
    end
  end

  module Assign1
    def tree
    			N_Oper.new(t1.tree, interval, '=').add(t2.tree)
    			end
  end

  def _nt_assign
    start_index = index
    if node_cache[:assign].has_key?(index)
      cached = node_cache[:assign][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_call_l
    s1 << r2
    if r2
      r3 = _nt__
      s1 << r3
      if r3
        if has_terminal?('=', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('=')
          r4 = nil
        end
        s1 << r4
        if r4
          r5 = _nt_I_
          s1 << r5
          if r5
            r6 = _nt_call_l
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Assign0)
      r1.extend(Assign1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r7 = _nt_call_l
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:assign][start_index] = r0

    r0
  end

  module CallL0
    def _
      elements[0]
    end

    def I_
      elements[2]
    end

    def a2
      elements[3]
    end
  end

  module CallL1
    def a1
      elements[0]
    end

    def tt
      elements[1]
    end
  end

  module CallL2
    def tree
    			tt.elements.inject(N_Oper.new(a1.tree, interval, "`", :left)){|res, e| 
    				res.add(e.a2.tree)}
    			end
  end

  def _nt_call_l
    start_index = index
    if node_cache[:call_l].has_key?(index)
      cached = node_cache[:call_l][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_tuple
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?('`', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('`')
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_tuple
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CallL0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CallL1)
      r0.extend(CallL2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:call_l][start_index] = r0

    r0
  end

  module Tuple0
    def _
      elements[0]
    end

    def I_
      elements[2]
    end

    def a2
      elements[3]
    end
  end

  module Tuple1
    def a1
      elements[0]
    end

    def tt
      elements[1]
    end
  end

  module Tuple2
    def tree
    			tt.elements.inject(N_Tuple.new(a1.tree, interval, ",")){|res, e| 
    				res.add(e.a2.tree)}
    			end
  end

  def _nt_tuple
    start_index = index
    if node_cache[:tuple].has_key?(index)
      cached = node_cache[:tuple][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ini
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?(',', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(',')
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_ini
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Tuple0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Tuple1)
      r0.extend(Tuple2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tuple][start_index] = r0

    r0
  end

  module Ini0
    def _
      elements[0]
    end

    def I_
      elements[2]
    end

    def a2
      elements[3]
    end
  end

  module Ini1
    def a1
      elements[0]
    end

    def tt
      elements[1]
    end
  end

  module Ini2
    def tree
    			tt.elements.inject(N_Oper.new(a1.tree, interval, ":")){|res, e|
    				res.add(e.a2.tree)}
    			end
  end

  def _nt_ini
    start_index = index
    if node_cache[:ini].has_key?(index)
      cached = node_cache[:ini][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_declare
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?(':', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(':')
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_declare
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Ini0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Ini1)
      r0.extend(Ini2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ini][start_index] = r0

    r0
  end

  module Declare0
    def _
      elements[0]
    end

    def I_
      elements[2]
    end

    def a2
      elements[3]
    end
  end

  module Declare1
    def a1
      elements[0]
    end

    def tt
      elements[1]
    end
  end

  module Declare2
    def tree
    			tt.elements.inject(N_Oper.new(a1.tree, interval, '@', :right)){|res, e| 
    				res.add(e.a2.tree)}
    			end
  end

  def _nt_declare
    start_index = index
    if node_cache[:declare].has_key?(index)
      cached = node_cache[:declare][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_add
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?('@', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('@')
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_add
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Declare0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Declare1)
      r0.extend(Declare2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:declare][start_index] = r0

    r0
  end

  module Add0
    def _
      elements[0]
    end

    def op
      elements[1]
    end

    def I_
      elements[2]
    end

    def m2
      elements[3]
    end
  end

  module Add1
    def m1
      elements[0]
    end

    def aa
      elements[1]
    end
  end

  module Add2
    def tree
    			aa.elements.inject(N_Oper.new(m1.tree, interval, '+', :left)){|res, e| 
    				res.add(e.m2.tree)}
    			end
  end

  def _nt_add
    start_index = index
    if node_cache[:add].has_key?(index)
      cached = node_cache[:add][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_mul
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?('\G[+-]', true, index)
            r5 = true
            @index += 1
          else
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_mul
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Add0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Add1)
      r0.extend(Add2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:add][start_index] = r0

    r0
  end

  module Mul0
    def _
      elements[0]
    end

    def op
      elements[1]
    end

    def I_
      elements[2]
    end

    def c2
      elements[3]
    end
  end

  module Mul1
    def c1
      elements[0]
    end

    def mm
      elements[1]
    end
  end

  module Mul2
    def tree
    			mm.elements.inject(N_Oper.new(c1.tree, interval, '*', :left)){|res, e| 
    				res.add(e.c2.tree, e.op.text_value)}
    			end
  end

  def _nt_mul
    start_index = index
    if node_cache[:mul].has_key?(index)
      cached = node_cache[:mul][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_call_h
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt__
        s3 << r4
        if r4
          if has_terminal?('\G[*/]', true, index)
            r5 = true
            @index += 1
          else
            r5 = nil
          end
          s3 << r5
          if r5
            r6 = _nt_I_
            s3 << r6
            if r6
              r7 = _nt_call_h
              s3 << r7
            end
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Mul0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Mul1)
      r0.extend(Mul2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:mul][start_index] = r0

    r0
  end

  module CallH0
    def t2
      elements[1]
    end
  end

  module CallH1
    def t1
      elements[0]
    end

    def cc
      elements[1]
    end
  end

  module CallH2
    def tree
    			cc.elements.inject(N_Oper.new(t1.tree, interval, "`", :left)){|res,e|
    				res.add(e.t2.tree)}
    			end
  end

  def _nt_call_h
    start_index = index
    if node_cache[:call_h].has_key?(index)
      cached = node_cache[:call_h][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_term
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          if has_terminal?('\G[ \\t]', true, index)
            r5 = true
            @index += 1
          else
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s3 << r4
        if r4
          r6 = _nt_term
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CallH0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(CallH1)
      r0.extend(CallH2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:call_h][start_index] = r0

    r0
  end

  module Term0
    def _
      elements[1]
    end

    def a
      elements[2]
    end

    def I_
      elements[3]
    end

  end

  module Term1
    def tree; a.tree; end
  end

  def _nt_term
    start_index = index
    if node_cache[:term].has_key?(index)
      cached = node_cache[:term][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('(', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r2 = nil
    end
    s1 << r2
    if r2
      r3 = _nt__
      s1 << r3
      if r3
        r4 = _nt_assign
        s1 << r4
        if r4
          r5 = _nt_I_
          s1 << r5
          if r5
            if has_terminal?(')', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(')')
              r6 = nil
            end
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Term0)
      r1.extend(Term1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r7 = _nt_number
      if r7
        r0 = r7
      else
        r8 = _nt_symbol
        if r8
          r0 = r8
        else
          r9 = _nt_string
          if r9
            r0 = r9
          else
            r10 = _nt_code_block
            if r10
              r0 = r10
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:term][start_index] = r0

    r0
  end

  module Number0
  end

  module Number1
    def tree
    			N_Number.new(text_value, interval); end
  end

  def _nt_number
    start_index = index
    if node_cache[:number].has_key?(index)
      cached = node_cache[:number][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[1-9]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Number0)
      r0.extend(Number1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:number][start_index] = r0

    r0
  end

  module Symbol0
  end

  module Symbol1
    def tree
    			N_Symbol.new(text_value, interval); end
  end

  def _nt_symbol
    start_index = index
    if node_cache[:symbol].has_key?(index)
      cached = node_cache[:symbol][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[a-zA-Z_]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[0-9a-zA-Z_]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Symbol0)
      r0.extend(Symbol1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:symbol][start_index] = r0

    r0
  end

  module String0
  end

  module String1
    def tree
    			N_String.new(text_value, interval); end
  end

  def _nt_string
    start_index = index
    if node_cache[:string].has_key?(index)
      cached = node_cache[:string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("\"", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("\"")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[^"]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?("\"", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("\"")
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(String0)
      r0.extend(String1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string][start_index] = r0

    r0
  end

  def _nt_EOL
    start_index = index
    if node_cache[:EOL].has_key?(index)
      cached = node_cache[:EOL][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("\r\n", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("\r\n")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('\G[\\r\\n]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:EOL][start_index] = r0

    r0
  end

  def _nt_empty
    start_index = index
    if node_cache[:empty].has_key?(index)
      cached = node_cache[:empty][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_empty_line
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

    node_cache[:empty][start_index] = r0

    r0
  end

  module EmptyLine0
    def _
      elements[0]
    end

    def EOL
      elements[1]
    end
  end

  def _nt_empty_line
    start_index = index
    if node_cache[:empty_line].has_key?(index)
      cached = node_cache[:empty_line][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt__
    s0 << r1
    if r1
      r2 = _nt_EOL
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(EmptyLine0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:empty_line][start_index] = r0

    r0
  end

  def _nt__
    start_index = index
    if node_cache[:_].has_key?(index)
      cached = node_cache[:_][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[ \\t]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

    node_cache[:_][start_index] = r0

    r0
  end

  module I_0
    def EOL
      elements[0]
    end

    def _
      elements[1]
    end
  end

  module I_1
    def _
      elements[0]
    end

  end

  def _nt_I_
    start_index = index
    if node_cache[:I_].has_key?(index)
      cached = node_cache[:I_][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt__
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_EOL
      s3 << r4
      if r4
        r5 = _nt__
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(I_0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(I_1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:I_][start_index] = r0

    r0
  end

end

class EtaParser < Treetop::Runtime::CompiledParser
  include Eta
end

