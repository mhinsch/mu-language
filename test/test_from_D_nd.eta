This is the test program from the D website rewritten in Eta.


{
import std#stdio

main: | args: Vec String =>
	{ 
    println "Hello World, Reloaded"

    cl: (CmdLin String) args
	
	loop` 
		[ (arg, argNum, suffix): cl.each##
        println` argNum, suffix, "arg: ", arg
		]

	// ` wouldn't work since it binds lower than :
	tmp: 
	do	[
		// Uppercase, thus type
		Specs: (count : Int, allocated : Int)
	
		argspecs: |^&Specs =>
			[
			s!: new Specs
			s.count = main.args.length	
			s.allocated = typeof args .sizeof
			main.args.each | arg =>
				\ s.allocated += arg.length * (typeof arg 0).sizeof
				
			^ s
			]
		]

	println` "argc = \{tmp.argspecs.count}, allocated = ", 
		tmp..argspecs..allocated
	}

CmdLin: | STRING: Type => 
\ Class {

public 

	// not consistent yet
    init: |($!, .args!) => {}

	// should actually be:
	// each (block (STRING, int, STRING):) : ()
	each: |($, yield: |(STRING, int, STRING) ) =>
		{
		n: 0
		loop \ yield ($.args.each#, (n = $+1), suffix n)
		}
		
    suffix: |($, n: Int, ^STRING) =>
    	{
        suffix!: "th"
        
		switch` n,
			[
			| 0 => \ suffix = "st"		
			| 1 => \ suffix = "nd"
			| 2 => \ suffix = "rd"
			| $ => []
			]
		
		^ suffix
		}

private

    args: ~> Vec STRING
}
