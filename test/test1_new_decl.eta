{

;; : binds a name in the next surrounding scope
;; a scope in this case is:
;; - {}, []
;; - function call

;; constant
a: 3

;; the type of the new variable is the type of the RHS expression
;; explicit type, init
f: Float 1.7
;; same, plus new type declaration
;; should not work as scope is limited to ()?
;; RHS of :: is symbolic anyway, so...
f2: (MyFloat: Float) 1.7

;; would be good though, so that generics could be declared as:

fun: (x: (T: Type))

;; if so, what about this:

x: MyT: Type (a: Int, b: Float)

;; default init
;; without semantic capitalization we would need Int()
d: Int

;; those should be (structurally) equivalent:
t1: (Int, Int) (1, 1)
t2: (1, 1)



t3: (a: Int, b: Int)			;; <--- we need this for function calls 
								;; (e.g. if` then: else:)

t4: (.a: Int, .b: Int)			;; ???
t5: ($a: Int, $b: Int)			;; ???
t6: [a: Int, b: Int]			;; ???
t7$(a, b): (Int, Int)			;; ???
t8.(a, b): (Int, Int)			;; ???

T1: Type (Int, Int)
T1: Type (_0 @ Int, _1 @ Int)	;; the same?????
T3: Type (a @ Int, b @ Int)		;; ?????
T1: Type (_0: Int, _1: Int)		;; why not like this?????
T3: Type (a: Int, b: Int)		;; ?????
T1: Type [_0: Int, _1: Int]		;; or this?????
T3: Type [a: Int, b: Int]		;; ?????

;; should actually be:

T1: (Int, Int)
T1: (a: Int, b: Int)


a: 1							;; (1)			Int	
b: 1							;; (1)			Int
c: 1, 1							;; (1 1)		Int, Int

d1: a, b						;; (1 1)		Int, Int			
d2: c, b						;; ((1 1) 1)	(Int, Int), Int	
;; what about literals?
;; this must hold: fn (1, 1) === fn (a, b)
d3: 1, 1						;; (1 1)	[Int, Int]			

E: (x::Int)
e: (y::E)


a:1, b:2						;; anonymous tuple of variable bindings
								;; names are bound *within* tuple (eq. to x.a)
								;; thus they are not accessible in this case
								;; (except for something like $.a)

fun` a:1, b:2					;; in this case the names are bound within the 
								;; argument tuple, thus accessible from fun body
fun` c:3						;; ***and what about this!***

								;; solution: ':' *always* operates within the current expression
								;; objects disappear at the end of the expression

fun` c:3						;; c bound within function call, disappears afterwards
c: 3							;; c bound within surrounding expression (top-level b_exp)

a = c: 3 + a * c				;; c bound within call to '+'
a = plus(c: 3, mult(a, c))		;; eq.
								;; *** accessible later on in the same expression?
								;; *** does '+' match at this point?
								;; *** general question - does a fun call with bindings only match for equal names?
								;; *** for function call with bindings - does order matter?
a = 3 + $ * c					;; *** idea: args of current top-level (underneath scope) expression match $, $1, $2, ... (????)

(a, b): (1, 2)					;; ':' operates in the current context =>
								;; somewhat counterintuitively this should be 
								;; two separate decls.

switch` x,
	[
	| 1 				=> [a = 4]
	| 2 | 4 -- | 9		=> [a = 7]
	| p: Int (10--100)  => [a = p]
	| $ 				=> [a = 0]
	] ;; making it a uniform tuple allows for generalized optimizations
	  ;; and error checking (e.g. missing cases)
	;; how to distinguish between range matching Int and range matching Range?

;; could | be implicit on LHS of =>?
;; would make function decl a bit more mainstream

;; no need for explicit switch? like this:
;; WRONG!!!, matches fizzle since they are not applied to anything
[
	| 1 				=> [a = 4]
	| 2 | 4 -- | 9		=> [a = 7]
	| p: Int (10--100) => [a = p]
	| $ 				=> [a = 0]
] x

;; or even this:
;; WRONG!!!, matches fizzle since they are not applied to anything
[
	1 					=> [a = 4]
	2 | #(4,9)			=> [a = 7]
	(p: Int #(10,100)) 	=> [a = p]	;; somewhat redundant since x is bound anyway
	$ 					=> [a = 0]
] x

;; problems:

;; Why are [] required around the list? Why not ()?
;; function decl implies that match literals are "lazy"
;; in that case a list of match literals (using '()') should be totally fine
;; problems with precedence for switch?
;;		if , is lower than => it should work (which it should anyway, otherwise Hashes break)
;; so we get:
;; NOTE: only works if _APPLY_ is distributive
(
	1 					=> [a = 4]
	2 | #(4,9)			=> [a = 7]
	(p: Int #(10,100)) 	=> [a = p]	;; somewhat redundant since x is bound anyway
	$ 					=> [a = 0]
) x

;; now, this is weird...
;; Makes sense, though. This is the unsafe version without any consistency checks,
;; just applies every single match in order
;; switch OTOH a) checks for completeness, b) drops out after first match
;; therefore needs expr instead of value

;; ':' is inconsistent between match literals and others
;; for matches repeat inits are possible, join patterns (= overloading)

;; Why does the LHS of => not require [], but the RHS does?
;; LHS are literals, should be fine

;; '=>' overloaded for T,Value and T,Expr, therefore usable in Hash


typeof: | ($: TYPE:, ^Type) => \ ^^ TYPE

;; decl('typeof', match(tuple(decl($, decl(TYPE)), context(Type)), expr(ret(TYPE))))

;; matching
;; * literals *always* match themselves
;; * only types overload => arg/member names can't distinguish matches
;; * unnamed structure always matches
;; * named matches always create local binding
;; * named structures match types *and* names
;; * match on type expression != match on value expression?

;; RHS of | must be statically knowable
;; types of matches:

AType1, AType1			;; eq. to ==
AType1, AType2			;; eq. to match: AType1, AType2, ^Bool
AType1, Type			;; eq. to instanceof 
Type, Type

;; match return type from context, needs explixit ignore

;; *** match expr against values of given type 
| 1						;; x == 1 				number
| 0..100				;; x .outOf 0..100		range (valid for Int, Range Int)
						;; x == 0..100			??
|0 .. |100				;; maybe like this?
| Int					;; x == Int
						;; x .type == Int		??
| (a: Int, b: Float)	;; named tuple type
| (a @ Int, b @ Float)	;; named tuple type

;; *** match type of given variable
| $: Int				;; any integer
| Int					;; any integer
| $: (Int, Float)		;; tuple type
| (a: Int, b: Float)	;; named tuple type?; how to match just the type?
| (a: $=1, b: $=1.0)	;; matches exact value or structure + default?
| ($a: 1, $b: 1.0)		;; matches exact value or structure + default?
| Type (a: Int, b: Float)	;; matches type?
| $: TYPE: $			;; bind just the type of a variable
| a: TYPE: $			;; bind var and type
| a: $					;; bind variable of any type
| T: Type				;; bind a type

;; *** how to do function args in the new decl style
;; *** how to distinguish default arg values from plain


;; *** another tuple problem: ***

a: | (a1:Int, a2:Int), a3:Int=10 => {}

a: | a1:Int, a2:Int, a3:Int=10 => {}

a(1, 2)		;; which overload gets selected?
			;; no anonymous types in parameter lists?

x : (1, 2)
a x			;; would this be unambiguous?

;; are function calls special?


;; function with side-effects
!c(): Int ^ {
	use \ a, ba 
	text : "Hello World"
	..print` text ++ endl, a, b
	
	^ 3
	}


;; function with side-effects
!c: | ^Int => 
	{
	a::, ba::
 
	text : "Hello World"
	..print` text ++ endl, a, b
	
	^ 3
	}

;; <VAR> : <INITV>
;; <VAR> : <TYPE> <INITV>
;; <VAR> : <INITV> . <TYPE> 

f1: Int 2

f2: ^Int ` { ^ 2 }

fun_d: 
	{
	Int <- (a1 : Float, a2 : 3.7)
	
	-> a1.Int * a2.Int
	}

fun_e: |(a1: Float, a2: 3.7?, ^: Int) =>
	{
	
	^^ a1.Int 
	}

square: | a1: Float => \ ^ a1.Int * a1.Int

max: 0
([1, 2, 3, 4]).map` | x: => \ if` x>max, \ max=x


fun_e: [a1 : Float, a2 : 3.7, ^: Int] ::
	{
	
	^ a1.Int 
	}

fun_f (a1 : Float, a2 : 3.7) : Int <- 
	{
 	-> a1.Int * a2.Int
	}

fun_f : Int (a1 : Float, a2 : 3.7) ->
	{
 	<- a1.Int * a2.Int
	}

fun_f : (a1 : Float, a2 : 3.7, <- : Int) ->
	{
	$<- = 2

 	<- a1.Int * a2.Int
	}

fun_f : ^Int (a1 : Float, a2 : 3.7) \ ^ a1.Int * a2.Int


e : ()->(()->Int) `
	{
	;; how to return the function instead of the value?
	;; out: b?
	;; or like this?
	<- &b
	}

;; how to make these equivalent?
;;{ d } 3.5
;;d 3.5

;; if they are, what about this?
;;{-> f::Float; puts f; d} 3.5

;; maybe like so?
;;{ d } () : 3.5

;; what do these do and why?
e
;; if this is supposed to call b, b () has to be forbidden
;; if it calls e, then e equiv. e() 
e ()
e () : ()


if` a>b, then:
	{
	
	}, else:
	{
	}

;; what's the difference between a, b and c?
;; difference between type of variable and type of expression?
;; to get typeof c == '()! -> Int', c has to be prevented from exec. or has 
;; to be made a compile-time operator on symbol
;; maybe:
;; typeof c				;; symbol
;; >	()! -> Int
;; typeof (c)			;; expression
;; >	Int			
;; BUT: "lazy" operator needed anyways for 
;; c = {...}, assigning function poInter
;; a c, using c as callback
;; maybe:
;; c! = {...}, not needed?, implicit in =
;; a c?


print a
print b
print c
print d 3.5


;;d :: type = Int

;; d2[e2::type] :: type = e2->() 
;; not supported yet

prepare_problem (aa : Int ()) :
	{
	problem (a :: Int) :
		{
		;; how to make return actually return??
		;; anonymous vs. named blocks
		;; static vs. dynamic execution?
		;; type of the assigned variable 
		;;   it's just a literal that's used in an ini, after all
		;; thus if takes a block, whereas ::() takes a function
		if` a<0, 
			{<-}, 
		else: 
			\ problem(a-1)
		}
	
	problem aa
	}

}

Test :: class :
	{
	a :: Int
	b :: Float
	
	__: (a::Int, b::Float)
		{
		$a : a
		$b : b
		}
	
	print () :: () : ; print` $a, $b
	}

t :: Test : (1, 3.5)

t.print

;; ==

Test :: namespace :
	{
	_type :: type :
		{
		a :: Int
		b :: Float
		}

	__: (_$::_type, a::Int, b::Float)


;; ` could be a (very low precedence) prefix, generally binds tuples

;;::
;;	symbol, type
;;	symbol, kind

;; use $... as references within tuple?

a = a + 1

__=` a!, a+1
__=` a!, $1+1

print: |($s: Bla, $out: ostream, $format: Format) =>
	{
	;; args always with $?
	$out ++ $$.prop
	}


;; use name args for low binding, name(args) for high binding??
;; => newline after fun doesn't work anymore
;; e.g.

do
	[
	...
	],
while: [test]

fun a, b, c
x * sin(a)
sin a*f + sin(a*f) + 3

now = 3 + time * 3
res = test.if [do_this], [do_that]


`if` test,
	...

;; is this allowed:

a = (
	1
	2
	3
	4
	)

;; or this:

a = (
	1, 2, 3
	4, 5, 6
	7, 8, 9
	)

;; if so, what is this:

a = (
	1, 2, 3

	4, 5, 6

	7, 8, 9
	)

;; or this:

a = (;1, 2, 3; 4, 5, 6; 7, 8, 9;)

;; use \ for char, symbols, custom literals
;; binds until next WS
;; parsed at compile time, custom literals defined by compile-time regex

\a	;; 'a'
\this-is-a-symbol
\176km/h
