// & means guaranteed not to be a copy

// a needs to be a ref so that identity can be compared
a_scan(m @ Model!, a @ &Animal!) @ () :
	{
	found @ (Pos, bool) : m.food.findResource(a.pos, m.p.foodVisibility)
	
	if` found._1,
		{
		rawDest @ Pos : a.dest(m.width)
		a.doDisperse
		m.movement` a!, rawDest, {Model::endMove}
		<-
		}

	// shouldn't that be &!, so that refs can be redirected (e.g. while resizing the array)?
	// or build handling of refs into special type of array? (but would extend to every container...)
	neighbours @ vec[&Animal!, Pos]
	m.collectNeighbours` a.pos, m.p.visibility, neighbours!
	neighbours.shuffle` rng
	
	neighbours.each!`
		{
		-> (na, np) @ (&Animal!, Pos)
		
		if na === a, next

		state @ int : na.state

		if` state =\= Animal::st_run &&
			state =\= Animal::st_disperse &&
			state =\= Animal::st_fight &&
			a.engage,
			{
			// NL replaces , between ()
			// would that work?
			if ( m.resolveEncounter(a!, na!, np)
				\<-
			else:
				{
				a.doScan; m.schedule(a!, {Model::a_scan}, m.p.peaceTime)
				<-
				} )
			}
		}
		
	a.doMove
	p.movement` a!, found, \Model::a_arriveAtResource
	}

