This is the test program from the D website rewritten in Eta.


{
import std.stdio

bla : 45	

main(args @ vec[string]) @ () :
	{
    println "Hello World, Reloaded"

    cl : CmdLin[string].new args
	
	loop`
		{
		(arg, argNum, suffix) : cl.each#
        println` argNum, suffix, "arg: ", arg
		}

	tmp @ module :
		{
		specs @ struct : { (count, allocated) @ int }
	
		argspecs @ () >> ~>specs :
			{
			s : specs.new
			s.count = main.args.length	
			s.allocated = typeof(args).sizeof
			main.args.each \ >> arg@; s.allocated += arg.length * typeof(arg[0]).sizeof
				
			<< s
			}
		}

	println` "argc = \{tmp.argspecs.count}, allocated = ", 
		tmp.argspecs.allocated
	}

CmdLin[STRING @ type] @ class :
public {
    init ($!, .args!) @ ()

	// should actually be:
	// each (block (STRING, int, STRING):) : ()
	each ($, yield @ (STRING, int, STRING) >> () ) @ () :
		{
		n : 0
		loop \ yield ($.args.each#, (n = $+1), suffix n)
		}
		
    suffix ($, n @ int) @ STRING :
    	{
        suffix : "th"
        
		// structure: int, (int, ex), (int, ex), ..., ex
		switch` n,
		case: (0
			\ suffix = "st"),	// block keeps binding to local context
		case: (1
			\ suffix = "nd"),
		case: (2
			\ suffix = "rd"),
		default: \
		
		<- suffix
		}
    } ++
	{
    args @ ~> vec[STRING]
	}
}
