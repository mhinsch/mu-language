begin

// constant
a as int = 3

// pure function
// b () as int =
b as () to int = 
	do
	a as int = 4
	
	out: a - 1
	end

// function with side-effects
// c ()! as int
c as ()! to int =
	do
	use ;a, b
	text is "Hello World"
	print: text ++ endl, a, b
	
	out 3
	end

d as (a1 as float) to int =
	do
	out a1.int
	end

e as ()to(()to int) =
	do
	// how to return the function instead of the value?
	// out: b?
	// or like this?
	out: ;b
	end

// how to make these equivalent?
//do d end 3.5
//d 3.5

// if they are, what about this?
//doto fasfloat;; puts f;; dend 3.5

// maybe like so?
//do d end () : 3.5

// what do these do and why?
e
// if this is supposed to call b, b () has to be forbidden
// if it calls e, then e equiv. e() 
e ()
e () : ()

if: a>b, then::
	do
	
	end, else::
	do
	end

// what's the difference between a, b and c?
// difference between type of variable and type of expression?
// to get typeof c == '()! to int', c has to be prevented from exec. or has 
// to be made a compile-time operator on symbol
// maybe:
// typeof c				// symbol
// >	()! to int
// typeof (c)			// expression
// >	int			
// BUT: "lazy" operator needed anyways for 
// c = do...end, assigning function pointer
// a c, using c as callback
// maybe:
// c! = do...end, not needed?, implicit in =
// a c?


print a
print b
print c
print d 3.5


//d as type = int

// d2[e2astype] as type = e2to() 
// not supported yet

prepare_problem as (aa as int)to() =
	do
	problem as (a as int)to() =
		do
		// how to make return actually return??
		if: a<0, do return end, 
		else:: ; problem: a-1
		end
	
	problem aa
	end

end


//as
//	symbol, type
//	symbol, kind
