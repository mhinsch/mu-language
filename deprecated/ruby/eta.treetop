

grammar Eta

	rule program
		preamble code:code_block empty	{def tree; code.tree; end}
	end

	rule preamble
		(empty_line / pre_text_line)*
	end

	rule pre_text_line
		_ [^{\n\r] (!EOL .)* EOL
	end


	rule code_block
		'{' exprs:expressions '}'		{def tree; exprs.tree; end}	
	end

	rule expressions
		ex1:expression ee:(EOL ex2:expression)* { def tree
			ee.elements.inject(N_Block.new(ex1.tree, interval, "{}")){|res,e|
				res.add(e.ex2.tree)}
			end }
	end

	rule expression
		_ a:assign _					{def tree; a.tree; end}	/
		_
	end
	
	
	rule assign
		t1:call_l _ '=' I_ t2:call_l	{def tree
			N_Oper.new(t1.tree, interval, '=').add(t2.tree)
			end} /
		call_l
	end
	
	rule call_l
		a1:tuple tt:(_ '`' I_ a2:tuple)*	{def tree
			tt.elements.inject(N_Oper.new(a1.tree, interval, "`", :left)){|res, e| 
				res.add(e.a2.tree)}
			end}
	end
	
	rule tuple
		a1:ini tt:(_ ',' I_ a2:ini)*	{def tree
			tt.elements.inject(N_Tuple.new(a1.tree, interval, ",")){|res, e| 
				res.add(e.a2.tree)}
			end}
	end

	rule ini
		a1:declare tt:(_ ':' I_ a2:declare)*	{def tree
			tt.elements.inject(N_Oper.new(a1.tree, interval, ":")){|res, e|
				res.add(e.a2.tree)}
			end}
	end

	rule declare
		a1:add tt:(_ '@' I_ a2:add)*		{def tree
			tt.elements.inject(N_Oper.new(a1.tree, interval, '@', :right)){|res, e| 
				res.add(e.a2.tree)}
			end}
	end

	rule add
		m1:mul aa:(_ op:[+-] I_ m2:mul)*		{def tree
			aa.elements.inject(N_Oper.new(m1.tree, interval, '+', :left)){|res, e| 
				res.add(e.m2.tree)}
			end}
	end
	
	rule mul
		c1:call_h mm:(_ op:[*/] I_ c2:call_h)*	{def tree
			mm.elements.inject(N_Oper.new(c1.tree, interval, '*', :left)){|res, e| 
				res.add(e.c2.tree, e.op.text_value)}
			end}
	end
		
	rule call_h
		t1:term cc:([ \t]+ t2:term)*		{def tree
			cc.elements.inject(N_Oper.new(t1.tree, interval, "`", :left)){|res,e|
				res.add(e.t2.tree)}
			end}
	end
	
	rule term
		'(' _ a:assign I_ ')'			{def tree; a.tree; end} /
		number / 
		symbol / 
		string /
		code_block
	end
	

	rule number
		[1-9] [0-9]*				{def tree
			N_Number.new(text_value, interval); end}
	end
	
	rule symbol
		[a-zA-Z_] [0-9a-zA-Z_]* 	{def tree
			N_Symbol.new(text_value, interval); end}
	end

	rule string
		"\"" [^"]* "\""				{def tree
			N_String.new(text_value, interval); end}
	end

	rule EOL
		"\r\n" 	/ 
		[\r\n]		
	end
	
	rule empty
		empty_line*					
	end
	
	rule empty_line
		_ EOL						
	end
		
	rule _
		[ \t]*
	end

	rule I_
		_ (EOL _)?				
	end
end
